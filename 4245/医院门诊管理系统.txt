1.    答题提醒
1)   请仔细阅读规格文档，理解规格文档估计需要花费20~30分钟来理解，请务必看清楚要求再动手。
2)   C/C++编译环境统一VC 2005，请不要使用标准C/C++以外的库或者方法，否则可能出现编译错误导致无法阅卷。
3)   如果考题与日常工作/生活接近，请考生以规格为准，不要类比相似案例。
4）已有C语言的代码框架，可以参考。
2.    总体说明
考生需要模拟实现一个简单的医院门诊管理系统，实现系统初始化、挂号、就诊、缴费、查询的功能。
病人挂号、缴费时不需要考虑排队情况，就诊阶段需要考虑排队情况。
3.    系统规则
一、规格中医院仅有一名医生，医生允许排队就诊的病人最大数量限定为4人。
每名病人由唯一的病人ID进行区分，病人分为有社保和无社保两种类型（0表示无社保病人，1表示有社保病人），每名病人拥有一定的现金，同时有社保的病人社保帐户上也具有一定的金额。
病人类型
含义
0
无社保病人
1
有社保病人
医生收费标准及病人（总数为6）信息描述在下面两个表格中，这些信息在考试框架中进行定义，考生在实现功能代码时可直接使用。
费用信息：
挂号费用
处方费用
10 
50
病人信息：
病人ID
病人类型
现金金额
社保金额
pat01
0 
100 
0
pat02 
1 
100 
100
pat03 
0
100
0
pat04 
1 
100
50
pat05 
1 
10 
10
pat06 
1 
20 
10
二、挂号
1、病人一次看病结束后（缴费结束）才允许再挂号。
2、病人挂号时，如果医生名下排队等待就诊的病人数量已经达到上限，那么此次挂号失败。
3、有社保的病人优先用社保金额支付挂号费用，如果社保金额不够支付挂号费用，则全部用现金支付的方式挂号(挂号时不允许社保支付一部分，现金支付一部分)，如果现金也不够支付挂号费用，则该病人挂号失败；没有社保的病人，只能用现金挂号，如果现金不够，则直接挂号失败。挂号成功后，病人进入排队就诊阶段。
(系统需要严格按照以上先后顺序进行逻辑判断并给出对应的返回信息。)
 
三、就诊
1、排队就诊阶段如果前面的病人就诊完成，后边的病人排队顺序则相应提前。
2、医生每次诊治病人开出的处方都相同（即药品费用相同）。就诊完成后，该病人进入缴费阶段。
（就诊阶段，医生名下的病人按照挂号的先后顺序进行排队。）
 
四、缴费
1、挂号时从社保扣款的病人，系统优先从其社保中扣除医生所开处方的药品费用，如果社保不够则从现金中扣除（系统只能从社保或者现金中一次性扣除全部费用，不能社保扣一部分，现金扣一部分）；挂号时从现金扣款的病人，系统从其现金中扣除药品费用。
2、如果病人的金额不够缴费，则该病人此次看病异常结束。
3、只要缴费成功，病人的这次看病就算正常结束。
4、无论是缴费时费用不够而异常结束还是缴费成功正常结束（此两种结束都认为本次看病已结束，查询病人信息中的状态为未挂号），病人均可在缴费结束后再次挂号（不考虑拿药的情况）。
（病人在缴费阶段不用排队，外部输入的缴费命令中带有缴费的病人ID，系统获取到该病人ID后处理该病人的缴费。）
5、挂号费在挂号时收取，处方费在缴费时收取，不是缴费时统一收取。
 
五、查询
1、支持查询病人当前处于哪个阶段以及病人社保余额、现金余额，如果病人正在排队就诊，需要列出病人排在第几位。
2、支持查询医生名下的病人排队情况。
 
4.    操作说明
1)   系统初始化
命令i（initial）接收到该命令后对系统进行初始化，系统在任何时候均可执行该命令初始化系统，初始化之后系统所有信息要求恢复到初始状态。
例1：系统启动后在接收到初始化命令：
      输入：i
      输出：E000
2)   病人挂号
系统初始化后，在客户端输入病人ID。
命令reg（register）表示病人挂号，其格式为：reg_patID，其中patID为病人的ID号。
挂号成功输出：
E001
病人看病未结束(即病人处于就诊、缴费阶段)，重复挂号输出：
E002
医生名下排队人数达到上限输出：
E003: 医生排队人数达到上限
例2：输入病人ID进行挂号：
      输入：reg_pat01
      输出：E001
3)   就诊
让医生诊治排在第1位的病人，命令执行完成后，被诊治的该病人状态变为待缴费。
命令diag（diagnose）表示让医生诊治病人，其格式为：diag，表示让医生诊治一名病人。
医生诊治病人成功输出：
E005
如果指定的医生名下无病人排队，输出：
E006
例3：假如医生名下有病人在排队，输入diag让其诊治一名病人：
      输入：diag
      输出：E005
4)   缴费
向系统输入病人ID，让系统处理该病人的缴费。
命令pay表示让系统处理病人缴费，其格式为：pay_patID，如pay_pat01表示让系统处理病人pat01的缴费。
如果该病人当前不处于缴费状态，输出：
E014
缴费成功系统输出：
E007
如果病人现金或者社保余额不够药品费用，输出：
E008
例4：让系统处理病人ID号为pat01的病人缴费，假如该病人的现金或社保足够支付药品费用:
     输入：pay_pat01
     输出：E007
5)   查询
系统支持按照医生或病人ID查询相关信息。
命令 qu(query)表示查询病人信息或者医生当前信息，其格式为：qu_quType 病人ID/医生，quType的取值范围为0和1，0表示按医生查询，1表示按病人ID查询。如qu_0-dct，表示查询医生当前的病人排队情况；qu_1-pat01表示查询ID为pat01的病人信息。
查询类型
含义
0
按医生ID查询
1
按病人ID查询
查询的病人处于待缴费阶段（状态2），输出（此处用问号代指金额或病人排队的数字，下同。）：
E012:patID 2社保帐户余额,现金帐户余额
查询的病人处于排队就诊阶段（状态1，最前面的病人输出为排在第1位），输出：
E012:patID 1排在第?位,社保帐户余额,现金帐户余额
查询的病人处于未挂号状态（待缴费、待就诊之外的其他状态，状态0），输出：
E012:patID 0 社保帐户余额,现金帐户余额
查询指定医生名下的病人排队情况，如果医生名下有病人排队，输出：
E013:dct 等待队列（patID1 patID2 patID3）
查询指定医生名下无病人排队，输出：
E013:dct 0
 
例5：查询医生名下的病人排队情况，假如pat01、pat02、pat03在该医生名下排队（pat01排在第一位、pat03排在最后一位）： 
输入：qu_0-dct
输出：E013:dct pat01 pat02 pat03
例6：pat01挂号后在医生名下排队待就诊，当前排在第1位，假如其现金帐户为100：
     输入：qu_1-pat01
 输出：E012:pat01 1 1,50,100
6)   命令汇总说明
命令定义如下表所示。考生不用考虑未在下表中列出的命令。
命令
命令字
命令格式
示例
说明
初始化
i(initial)
i
i
系统初始化
挂号
reg(register)
reg_病人ID
reg_pat01
病人pat01挂号。
 
就诊
diag (diagnose)
diag
diag
让医生诊治排在第一位的病人。
缴费
pay (pay)
pay_病人ID
pay_pat01
让病人pat01进行缴费
查询
qu (query)
qu_0(查医生名下的排队情况)/1(查病人信息)-dct/病人ID
qu_0-dct
qu_1-pat01
查询医生名下的病人排队情况
查询病人pat01的状态、余额信息
 
 
 
题目类别:	 字符串 
难度:	 挑战 
运行时间限制:	无限制
内存限制:	无限制
阶段:	 入职前练习 
输入:	 
依照说明中的命令码格式输入命令
 
 
输出:	 
 原因码汇总
原因码分类
原因码说明
初始化
E000:初始化成功
挂号
 
 
 
E001:挂号成功
E002:本次看病未结束
E003:医生排队人数达到上限
E004:无足够挂号费用
就诊
 
E005:诊治成功
E006:无病人排队
缴费
 
E007:缴费成功
E008:余额不足
E014:无该病人待缴费
查询
 
E012:patID 待缴费 社保帐户余额:?,现金帐户余额:?
E012:patID 待就诊 排在第?位,社保帐户余额:?,现金帐户余额:?
E012:patID 未挂号 社保帐户余额:?,现金帐户余额:? 
E013:dct等待队列 patID1 patID2
E013:dct无人排队
注：考生只需考虑上表中列出的原因码。
输出执行结果。
约束
1、所有指令格式的合法性、范围不做为测试点，考生不需要考虑。
2、测试用例中所有的命令必须以”i”开头，即所有的用例都是以初始化开始的。
3、输入命令的命令字与参数之间用”_”（下划线）隔开，命令的参数与参数之间用”-”（横线）隔开，命令与命令之间用”,”（英文逗号）隔开，命令行中不允许出现空格。
4、命令中输入的病人ID在预置的病人信息中不存在的情况不作为考点，考生不需要考虑。
5、仔细阅读题目规格，使用给出的参考代码框架，实现OpInit， OpRegister，OpDiag，OpPay，OpQuery五个函数的功能，函数已经定义好，直接修改即可。考生也可根据需要自行添加函数，输入输出功能可直接调用参考代码框架中的函数。
 
用例列表
编号
用例
预期输出
1
i,reg_pat01,qu_0-dct,qu_1-pat01
E000
E001
E013:dct pat01
E012:pat01 1 1,0,90
2
i,reg_pat01,reg_pat01
E000
E001
E002
3
i,reg_pat01,diag,reg_pat01
E000
E001
E005
E002
4
i,reg_pat01,reg_pat02,reg_pat03,reg_pat04,reg_pat05,qu_0-dct
E000
E001
E001
E001
E001
E003
E013:dct pat01 pat02 pat03 pat04
5
i,reg_pat01,reg_pat02,reg_pat03,reg_pat04,qu_0-dct,diag,reg_pat05,qu_0-dct
E000
E001
E001
E001
E001
E013:dct pat01 pat02 pat03 pat04
E005
E001
E013:dct pat02 pat03 pat04 pat05
6
i,reg_pat05,diag,pay_pat05,reg_pat05,qu_0-dct05,qu_1-pat05
E000
E001
E005
E008
E001
E013:dct pat05
E012:pat05 1 1,0,0
7
i,reg_pat01,qu_1-pat01
E000
E001
E012:pat01 1 1,0,90
8
i,reg_pat02,qu_1-pat02
E000
E001
E012:pat02 1 1 90,100
9
i,diag
E000
E006
10
i,reg_pat01,diag,diag
E000
E001
E005
E006
11
i,reg_pat01,diag,pay_pat01,diag
E000
E001
E005
E007
E006
12
i,reg_pat01,diag,pay_pat01
E000
E001
E005
E007
13
i,reg_pat05,diag,diag
E000
E001
E005
E006
14
i,reg_pat06,pay_pat06
E000
E001
E014
15
i,pay_pat06
E000
E014
16
i,reg_pat06,diag,pay_pat06,qu_1-pat06
E000
E001
E005
E008
E012:pat06 0 0,20
17
i,reg_pat01,diag,pay_pat01,qu_1-pat01
E000
E001
E005
E007
E012:pat01 0 0,40
18
i,reg_pat02,diag,pay_pat02,qu_1-pat02
E000
E001
E005
E007
E012:pat02 0 40,100
19
i,reg_pat04,diag,pay_pat04,qu_0-dct,qu_1-pat04
E000
E001
E005
E007
E013:dct 0
E012:pat04 0 40,50
20
i,reg_pat05,diag,pay_pat05,qu_0-dct,qu_1-pat05
E000
E001
E005
E008
E013:dct 0
E012:pat05 0 0,10
21
i,reg_pat03,diag,pay_pat03,reg_pat03,diag,pay_pat03,qu_0-dct,qu_1-pat03
E000
E001
E005
E007
E001
E005
E008
E013:dct 0
E012:pat03 0 0,30
 
 
 
样例输入:	
i,reg_pat01,qu_0-dct,qu_1-pat01
                   
样例输出:	
E000
E001
E013:dct pat01
E012:pat01 1 1,0,90
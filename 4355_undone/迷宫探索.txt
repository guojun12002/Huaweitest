在迷宫中找出最长环路的长度，不是找到出路。
 
详细描述：

迷宫是由一系列方格组成一个矩形区域，下图是一个 4 * 6 的迷宫 
每个方格中都有一条红色的斜线（/或者\），这是墙，无法通过。灰线不是墙，可自由跨越。 
在迷宫内，只能在相邻的（有公共边的才算相邻，公共顶点不算）三角形的区域之间相互移动。左上角灰色三角形，就是一个区域，从这个区域，可以移动到下面黄色三角形区域中。 
不能越界，只能在大的矩形范围内移动。左边紫色这种移动方式，是不允许的。 
可以看到，中间蓝色的分别是两条环路，环路长度指的是走完这条环路需要走过的三角区域个数，两条环路的长度分别是16和4；绿色的不是一条环路
 
图像 2.png
 
请实现如下接口
/* 功能：找出一个迷宫中的最长环路长度，以及总的环路个数
 * 输入：存放迷宫信息的记事本文件路径，该程序从文件中读取迷宫信息。该文件格式后面会说明
 * 输出：CycleCount，环路个数，上面的迷宫，CycleCount为2
* 返回：最长环路长度，上面的迷宫，应返回16.如果没有环路，返回-1.
 */
int FindLongestCycle(constchar* mazefile, int*CycleCount)
{
    /* 请实现*/
    return 0;
} 
 
 
迷宫信息：
本题例子中的迷宫以下面文本格式保存。
其中斜线，则表示对应方格中的墙。斜线之间无空格。
左边的字符串中的斜线和右边图画中的墙一一对应。

图像 3.png
 

随题目附带的两个用例，在testcase目录下。
每行结束以回车（”\r\n”）收尾，没有多余的空格。
最后一行结束，没有回车。
解题时，无需检查该文件格式，由用例保证格式正确。
 
约束：
环路都是简单环路。即除了第一个顶点和最后一个顶点外，其余顶点不重复出现的环路。不会有“8”字形，“6”字型这样的环路。
 
图像 4.png
 
 
迷宫宽和高不超过50，宽和高均大于1.
每个格子里都有一堵墙（也就是都会被填进一个斜线），不会出现空格子；
墙只有两种（/ 和 \），不会有其他类型。